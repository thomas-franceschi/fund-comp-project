Kyle Williams
Brittany DiGenova
Thomas Franceschi
-----------------
CSE 20212
Final Project Group Report
Due: 4/26/16
-----------------
BitBucket Repository Link:

https://bitbucket.org/fundcompproject/fund_comp_project/overview

=================================================================
Time Log:
Individual Logs
---------------------------------------------------------------------------------
Brittany DiGenova:
- 1 hour SDL Tutorials 2/26/2016, 2:50pm-3:50pm
- 2 hours SDL Tutorials 2/27/2016, 1:00pm-3:00pm
- 1 hour Team Meeting  3/3/2016, 9:00pm-10:00pm
- 1 hour SDL Tutorials 3/15/2016, 2:50pm-3:50pm
- 2 hours Team meeting Attempted to get walking animation working - 3/16/2016, 9:00pm-11:00pm
- 3 hours Designing Class Hierarchy for pokemon and potions 3/17/2016, 8:30pm-11:30pm
- 2 hours Designing and building battle and healing logic 3/20/2016, 5:00pm-7:00pm
- 2 hours Debuggin all of the classes working together and design simple driver 3/21/2016, 11:00pm-1:00pm
- 1 hour Team meeting - Discussed desired game features 4/6/2016, 10:20am-11:20am
- 3 hours Debugging Pokemon Classes figuring out pass by reference 4/12/2016 9:00pm-12:00pm
- 1 hour Team meeting - Scaled back ideas to reasonable amount and delegated tasks 4/13/2016, 10:20am-11:20am
- 3 hours Built and added composition for moves class 4/13/2016 7-10 PM 
- 2 hours Built algorithms for battling to take away hitpoints, instantiated pokemon 4/17/2016, 6:00pm-8:00pm
- 2 hours Restructuring classes, testing game in lab 4/18/2016, 2-4 PM
- 1 hour Team meeting - Worked on combining graphics and game logic, debugged hit detection 4/20/2016, 10:20am-11:20am
- 5 hours Built trainer class and functions, brought together my code with animation 4/23/2016, 4:00pm-9:00pm
- 5 hours Debug battling for trainers and pokemon 4/25/2016, 2:00pm-7:00pm
- 2 hours Writing manual/report/personal report/commenting code 4/26/2016, 11:00am-1:00pm
- 3 hours Team meeting - Combining, finetuning, debugging game before turn in 4/26/2016, 9:00pm-12:00am

---------------------------------------------------------------------------------
Thomas Franceschi:
Thursday 3/3/16 9 pm - 10 pm:
First Team Meeting: Brainstormed project ideas, how to implement them, general game flow.

Monday 2/29/16 3 pm - 4 pm:
Computing Lab: Worked through LazyFoo SDL tutorials

Tuesday 3/1/2016 7 pm - 8 pm:
Art brainstorming: Hand drew basis for maps/building interiors/game flow. 

Monday 3/14/16 3 pm - 4 pm:
Computing Lab: Worked through LazyFoo SDL tutorials

Monday 3/14/2016 8 pm - 10 pm:
LazyFoo Tutorials: Worked through more SDL tutorials on my own.

Sunday 3/20/2016 9 pm - 11 pm:
LazyFoo Tutorials: Worked through more SDL tutorials on my own.

Sunday 3/20/2016 11 pm - 12:30 am:
GIMP: Read documentation and practiced using GIMP to create/manipulate sprites, 
maps, etc. and created a demo sprite for the lab deliverable. Created a sprite 
sheet for a bouncing ball. Allignments was slightly off so some bits gets cut off 
of certain frames.

---------------------------------------------------------------------------------
Kyle Williams:

- 1 hour In-lab SDL tutorials. Developed milestones. Tried installing SDL libraries to be used natively on Xcode. 2/29/2016, 3:00pm-4:00pm
- 1 hour Initial team meeting. Talked project ideas, started developing ideas of implementation. 3/3/2016, 9:00pm-10:00pm
- 1 hour In-lab SDL tutorials. Was not able to get SDL working on Xcode for some reason. Decided to try to run it off of my Ubuntu VM. Worked on installing libraries there and checking out SDL functionality with a Linux based VM as opposed to Xcode. 3/14/2016, 3:00pm-4:00pm
- 1 hour More SDL tutorials. Worked through lesson 6. 3/16/2016, 8:00pm-9:00pm
- 2 hours Initial SDL2 Animation Attempt 3/16/2016, 9:00pm-11:00pm
- 2 hours Worked on SDL tutorials through lesson 14. 3/19/2016, 11:00am-1:00pm
- 1 hour Tried to jump ahead in SDL tutorials to control animation with keyboard. Was unsuccessful with trying to control a sprite from a Pokemon spritesheet. Decided to implement simply animating that sprite walking in different directions. 3/20/2016, 11:00pm-12:00am
- 1 hour Discussed desired game features in initial design 4/6/2016, 10:20am-11:20am
- 4 hours Walking functionality implemented on ND campus map 4/12/2016 7:00pm-11:00pm
- 1 hour Scaled back original design and assigned tasks 4/13/2016, 10:20am-11:20am
- 2 hours Update sprites for mechanics of motion 4/17/2016, 9:00pm-11:00pm
- 1 hour  Worked on combining graphics and game logic, debugged hit detection 4/20/2016, 10:20am-11:20am
- 5 hours Combined my code with Brittany's trainer and battle functionality 4/23/2016, 4:00pm-9:00pm
- 6 hours added more graphics for battle functionality, tested more 4/25/2016, 3:00pm-5:30pm and 7:00pm-10:30pm
- 7 hours Putting final touches on code comments, testing for bugs, writing final report and personal report 4/26/2016, 10:20am-12:00pm, 2:00pm-5:00pm, 6:40pm-9:00pm
- 3 hours Combining, finetuning, debugging game before turn in 4/26/2016, 9:00pm-12:00am 


Team Meeting Logs
-----------------

- 1 hour 	-> Initial team meeting 3/3/2016, 9:00pm-10:00pm
- 2 hours 	-> Initial SDL2 Animation Attempt 3/16/2016, 9:00pm-11:00pm
- 1 hour 	-> Discussed desired game features in initial design 4/6/2016, 10:20am-11:20am
- 1 hour 	-> Scaled back original design and assigned tasks 4/13/2016, 10:20am-11:20am
- 1 hour 	-> Worked on combining graphics and game logic, debugged hit detection 4/20/2016, 10:20am-11:20am
- 3 hours 	-> Combining, finetuning, debugging game before turn in 4/26/2016, 9:00pm-12:00am 

=================================================================

From a user perspective, this program begins when the user executes it. A graphics window will open and the user will see the trainer standing on the steps of Morrissey Hall. Initially, the trainer has squirtle and pidgey. The user can use the arrow keys to control the trainer and walk around the Notre Dame campus. If the user hold down the space bar, the trainer will run. If the user guides the trainer over the grass on the map, there is a chance that the trainer will encounter a wild Pokemon. If a wild Pokemon is encountered, the user will battle that Pokemon from the commmand line, using numbers to indicate desired moves to use on the wild Pokemon.

The objective of the game is to get four Pokemon to level 18 and then beat Fr. V (Morrissey's rector) in a trainer battle. The user simply needs to approach Fr. V to engage in battle. The zone around him is rigged
to run the trainer_battle function and is_winner() function when the user is close enough. This will play out a trainer battle with father V and then end the game if the user has beat the objective.

Internally, the first base class, Pokemon, contains all of the attributes that will be shared for all types of Pokemon. This includes hit points, attack, defense, level and name. The functions in the Pokemon class include battle 
and heal, as well as a non-default constructor with default fall backs. The battle and heal functions accomplish the key components of the game that will affect the pokemon's attributes. 
 The other main function is check_pokemon() which checks the pokemon's experience points and changes its level accordingly. As the level of the pokemon increases
the attributes also increase making the pokemon harder to defeat.

The first function heal combines the Pokemon class hierarchy and the Potion class. Potions have the power to increase a Pokemon's hit points a certain
amount depending on the potion. This value is stored in the 'healing_power' private member of a potion class. The heal function takes a potion as
an input and determines it's healing power by using a get function. The hit points of the called pokemon are then increased by the potion's 'healing_power'.
If the hit_points value is greater than the max (stord as max_hit_points) it is set back to max_hit_points. 

The second function battle contains the logic for the battles that will occur during the pokemon game. Battle is a Pokemon member function and takes a second
Pokemon as an input to account for both of the Pokemon in the fight. Each of the Pokemon begin with a certain number of available moves as well as a set of 
strengths and weaknesses stored in its private data. Each time that a Pokemon calls a move, the power_points for that move decreases (because it can only use a move so
many times). This is accomplished by using a 2D vector. The 2d Vector is 4 by 5 so that there are 4 moves available with max 5 uses each. After the first Pokemon calls a move,
that moves value in the 2D vector decreases by 1. Moves can only be called if the value being called is greater than 1. The battle function uses a while loop that continues
until either the pokemon or it's opponent have hitpoints greater than 0. A *-1 is used to switch wether the pokemon is attacking or defending the opponent every other turn.
This process rotates back and forth until one of the Pokemon faints (runs out of hit points). If the users pokemon has more than 0 hit points after the while loop is broken
then battle returns 1 for a player victory, otherwise the battle function returns 0 for a loss. 
	
The computer player will randomly choose from it's available moves by only accepting a move if it's pp is > 0 (this will be stored in the second dimension of the moves vector). 
If a moves value is >0 then some of those moves are still available and it can be used. Once a list of available moves have been made (the first dimensions of the 2D vector, a 
random generator will be used for the opponent pokemon to pick a move. We planned to incorporate strength and weakness features based on type but after putting many many hours into the game
we decided to scale back and did not incorporate this feature. The private members were left though so that we could add this feature in the future. 

The strengths and weaknesses functions have not been implemented yet because I ran out of time, but I spent time planning them out. In order to build the strengths and weaknesses
I will attach every movetype to a number (like an index) these numbers of move types will be stored in two seperate 2D vectors. The first being strengths, and the second being 
weaknesses. The second dimension of each move will be the index number of all the moves that are very effective (for strengths) or very detrimental (for weaknesses). I will then use
these 2D vectors in the attack and defend functions. Anytime a move is called, it's index number will be checked for the list of numbers that correspond to its strength and weaknesses
if the users' move's strengths==any of the opponents weaknesses, then the hit_points deducted by the attack will be increased. 

Internally, the main part of the program is in the pokemon file. This file contains the header file for the trainer class, and this file contains the LTexture class for the graphics window. This program begins with the LTexture class followed by function prototypes for methods not included in the LTexture class. Next are instantiation of the textures to be used for the graphics for the trainer, the backgrounds, the Pokemon, and the battle screen. Under those object instantiations are the function implementations for the LTexture class, including the constructor and destructor. The loadFromFile function loads the specified image from a specified path, sets the image color key, and creates a texture from the surface pixels. The loadFromRenderedText function is similar to the loadFromFile function, but it renders the text suface and creates the texture from surface pixels. The free function destroys the texture and sets its data members to NULL or 0. SetColor, setBlendMode, and setAlpha each call another set function from the SDL2 library, and were not explicitly used in our project. The render function was used heavily to render the intended image to the graphics window; this function also uses another function from the SDL2 library. 

The getWidth and getHeight functions return the width and height of the texture. The init function is used to create and sync the actual graphics window that the project is rendered in. The loadMedia function takes the paths to the .png images that are used in the project and loads them into a certain texture object, calling the loadFromFile method. This function is long, as many texture objects were used throughout the game. The close function calls the free method on all of the texture objects, destroys the SDL window and quits any SDL subsystems to clean up when the user decides to quit the game. The print function renders the background world, the inside of Morrissey if the player is inside Morrissey, and it renders the trainer in whichever direction the arrow keys are making him walk. The battleGFX function renders the battle graphics background, the trainer, the text indicating the user to look at the command line, and a picture of whichever Pokemon the user is battling. The xMoveLeft, xMoveRight, yMoveUp, and yMoveDown functions increase or decrease the top left position of where the background picture is being rendered in order to produce motion for the trainer. The trainer just faces different directions and moves his feet; the background is the image that is actual being translated across the graphics window. 

The wildBattle function uses a random integer to deteremine whether or not the trainer encounters a wild Pokemon when he is in the grass. If a wild Pokemon is encountered, the user will see the battle graphics from the battleGFX function and the encounter_pokemon method from the trainer class is called so the user can battle. The enterMorrissey and exitMorrissey functions use the trainer's x and y positions on the background image to determine if the trainer is inside Morrissey. An one is returned if the trainer is in Morrissey and this helps change the order that the graphics are rendered, so the trainer will appear to be inside Morrissey. The can walk function contains hard-coded parameters based on certain obstacles on the map. This function compares the trainer's x and y poistion to the constaints and limits where the trainer can walk.

Inside of main, a Trainer object is instantiated along with Moves objects, Potion objects, Pokemon objects (from the Pokemon type classes). The Moves objects are added to the Pokemon that were instantiated. Some Pokemon are initially given to the Trainer object along with some Potion objects. Then the SDL window is initialized, the media is loaded into the specified textures, and the program enters a while loop that continues to run until SDL_PollEvent exits out of the graphics window. Inside of the loop, the current arrow key state is checked in a series of if statements, depending on the arrow key that is held down, the program then renders the different pictures of the trainer sprite moving with one foot behind the other. In each movement, the background x and y coordinates are either increased or decreased based on which arrow key is being held down. The wildBattle function is called to see if the trainer has encountered a wild Pokemon. The default image for the trainer sprite is one that is standing with its feet in line, and the trainer faces the direction of the last pressed arrow key. Outside of the if statements, the program checks to see if the trainer is inside of Morrissey. The framecounter is incremented and the print function prints the background and trainer. Outside of the loop, the close function is called that frees the SDL resources and closes SDL before the program returns 0.

The trainer has a series of useful functions for battling other trainers and encountering pokemon. When a trainer encounters any type of battle the first step is to look for healthy pokemon, if there are none a message is outputted and the user restarts the game with healed pokemon. (Note we wanted to include a health center but this was not permitted by time). If the trainer encounters father V, the trainer_battle function is called which prompts the user to pick healthy pokemon and randomly picks an opponent pokemon. The battle continuously calls pokemon.battle(opponent_pokemon) until all the pokemon on one side or the other have fainted at which point the battle ends and the user is told who won. In order to check for healthy pokemon there is a function called dead_pokemon() that determines if they are all dead. The is_winner function in the trainer class is used to check if the trainer has at least four pokemon at level 18. If he does then the game ends with a congratulatory message. 

The output of all of this project was verified in increments. We used the Prototyping design type as we worked on little portions of the project and tried to produce a working product quickly before assessing and changing the code where is did not work as intended. For example, the trainer walking functionality was tested and perfected, as the battling functionality was tested and perfected before both code sets were combined and tested. The separate code modules were assessed again after they were all assembled into the final project to verify the intended output. The game was played frequently as well to make srue that everything worked as intended.